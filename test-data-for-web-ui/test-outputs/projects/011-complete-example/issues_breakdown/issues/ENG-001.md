# Database Schema & Migrations

**Issue ID**: ENG-001  
**Project**: User Profile Management (#011)  
**Status**: Pending  
**Priority**: High  
**Complexity Score**: 7/10  
**Estimated Hours**: 6h  

## Description

Create and implement database schema changes required for the user profile management system. This includes extending the existing `users` table with new columns and creating three new tables: `profile_privacy_settings`, `notification_preferences`, and `profile_audit_log`. All migrations must be reversible and backward-compatible.

## Acceptance Criteria

- [ ] Migration script extends `users` table with new profile columns (bio, location, website, profile_picture_url, profile_updated_at, deletion_requested_at, deleted_at)
- [ ] `profile_privacy_settings` table created with proper foreign keys and unique constraints
- [ ] `notification_preferences` table created with proper indexes
- [ ] `profile_audit_log` table created for tracking all profile changes
- [ ] All tables have appropriate indexes for performance
- [ ] Migration rollback script tested and working
- [ ] Seed data created for development environment
- [ ] Migration tested on staging with production data snapshot
- [ ] Database diagram updated in documentation

## Technical Details

### Tables to Create

**profile_privacy_settings**
- Primary key: id (serial)
- user_id (FK to users.id, CASCADE delete)
- field_name (varchar 50, enum values)
- is_public (boolean, default false)
- Unique constraint on (user_id, field_name)
- Index on (user_id, field_name)

**notification_preferences**
- Primary key: id (serial)
- user_id (FK to users.id, CASCADE delete)
- channel (varchar 20: email, push, sms)
- category (varchar 50: account_activity, product_updates, etc.)
- enabled (boolean, default true)
- Unique constraint on (user_id, channel, category)
- Indexes on user_id and enabled fields

**profile_audit_log**
- Primary key: id (serial)
- user_id (FK to users.id, CASCADE delete)
- action (varchar 100)
- changes_json (jsonb)
- ip_address (varchar 45)
- user_agent (text)
- created_at (timestamp with default)
- Indexes on user_id, created_at, and action

### Migration Strategy

1. Run in transaction for atomicity
2. Use IF NOT EXISTS for idempotency
3. Add columns to users table first
4. Create new tables in dependency order
5. Create indexes after data insertion
6. Update sequences if needed

## Dependencies

None - This is the foundational issue that other issues depend on.

## Testing Requirements

### Manual Tests
1. Run migration on clean database → verify all tables created
2. Run migration on existing database → verify no data loss
3. Run rollback migration → verify schema reverts cleanly
4. Insert test data → verify constraints work correctly
5. Check index usage with EXPLAIN ANALYZE

### Automated Tests
- Unit tests for migration scripts (if using migration framework with test support)
- Integration tests that verify schema structure
- Performance tests for index effectiveness

## Implementation Checklist

- [ ] Create up migration file with all schema changes
- [ ] Create down migration file for rollback
- [ ] Add migration to version control
- [ ] Test migration locally
- [ ] Run migration on staging environment
- [ ] Verify all indexes created correctly
- [ ] Create seed data for development
- [ ] Update schema documentation
- [ ] Get code review approval
- [ ] Deploy to production during low-traffic window

## Files to Modify

- `migrations/YYYYMMDD_create_profile_tables.sql` (new)
- `migrations/YYYYMMDD_rollback_profile_tables.sql` (new)
- `db/seeds/profile_seed_data.sql` (new)
- `docs/database_schema.md` (update)

## Reference Documents

- Technical Specification: Section 1 (Data Model)
- PRD: All sections (for understanding data requirements)

## Notes

- Use `node-pg-migrate` for migration management
- Ensure all timestamps use TIMESTAMP WITH TIME ZONE
- Add database diagram to documentation after completion
- Consider data volume when creating indexes (analyze query patterns)
- Coordinate with DevOps for production migration timing

## Risks & Mitigation

**Risk**: Migration fails midway on production  
**Mitigation**: Use transactions, test thoroughly on staging with production data snapshot

**Risk**: Indexes slow down writes  
**Mitigation**: Create indexes CONCURRENTLY in separate migration if needed

**Risk**: Existing data incompatible with new constraints  
**Mitigation**: Analyze existing data first, add data cleanup step if needed

