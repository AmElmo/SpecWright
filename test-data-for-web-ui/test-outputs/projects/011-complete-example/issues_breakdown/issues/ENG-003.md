# Image Upload & Processing Service

**Issue ID**: ENG-003  
**Project**: User Profile Management (#011)  
**Status**: In Progress  
**Priority**: High  
**Complexity Score**: 9/10  
**Estimated Hours**: 8h  

## Description

Implement complete image upload and processing pipeline for profile pictures. This includes client-side preprocessing, server-side validation and processing with Sharp, multiple size generation, S3 upload with CloudFront CDN integration, and proper error handling for all edge cases.

## Acceptance Criteria

- [ ] POST /api/v1/profile/picture accepts multipart/form-data uploads
- [ ] Client-side image compression reduces file size before upload (max 800px width)
- [ ] Server validates file size (5MB max), format (JPG/PNG/WEBP), and magic numbers
- [ ] Malware/virus scanning implemented (ClamAV or AWS GuardDuty)
- [ ] Sharp generates 4 sizes: 400px, 200px, 100px, 40px (all square cropped)
- [ ] Images converted to WebP format for optimal file size
- [ ] All sizes uploaded to S3 with public-read ACL
- [ ] CloudFront URLs returned in API response
- [ ] DELETE /api/v1/profile/picture removes images from S3 and database
- [ ] Upload progress tracking implemented
- [ ] Error handling for network failures, S3 failures, processing errors
- [ ] Rate limiting: 5 uploads per hour
- [ ] Old profile pictures deleted when new one uploaded
- [ ] Integration tests cover upload, processing, and deletion

## Technical Details

### Upload Flow

1. **Client Side (browser-image-compression):**
   ```javascript
   // Resize to max 800px width
   const compressedFile = await imageCompression(file, {
     maxSizeMB: 2,
     maxWidthOrHeight: 800,
     useWebWorker: true
   });
   ```

2. **Server Side (Multer + Sharp):**
   ```javascript
   // Receive upload
   upload.single('image')
   
   // Validate
   validateFileSize(5MB)
   validateMimeType(['image/jpeg', 'image/png', 'image/webp'])
   validateMagicNumber()
   scanForViruses()
   
   // Process with Sharp
   const sizes = [400, 200, 100, 40];
   for (const size of sizes) {
     await sharp(buffer)
       .resize(size, size, { fit: 'cover' })
       .webp({ quality: 90 })
       .toBuffer();
   }
   
   // Upload to S3
   const urls = await uploadToS3(processedImages, userId);
   
   // Update database
   await updateUserProfilePicture(userId, urls.large);
   
   // Return URLs
   return { profile_picture_url: urls.large, sizes: urls };
   ```

3. **S3 Structure:**
   ```
   bucket: profile-images-prod
   path: {user_id}/
     - large.webp (400x400)
     - medium.webp (200x200)
     - small.webp (100x100)
     - thumb.webp (40x40)
   ```

### API Endpoints

**POST /api/v1/profile/picture**
- Content-Type: multipart/form-data
- Field name: image
- Max size: 5MB
- Formats: JPG, PNG, WEBP
- Rate limit: 5 per hour
- Response time target: < 3s (excluding network)

**DELETE /api/v1/profile/picture**
- Auth: Required
- Side effects: Delete all 4 sizes from S3, clear database URL
- Response: 204 No Content

### Error Handling

**Client-Side Errors:**
- File too large → "File must be under 5MB. Please choose a smaller image."
- Invalid format → "Please select a JPG, PNG, or WEBP image."
- Compression failed → "Failed to process image. Please try another file."

**Server-Side Errors:**
- 413 Payload Too Large → "File exceeds 5MB limit"
- 415 Unsupported Media Type → "Invalid image format"
- 422 Unprocessable Entity → "Image processing failed"
- 429 Too Many Requests → "Upload limit reached (5 per hour)"
- 500 Internal Server Error → "Upload failed. Please try again."
- 503 Service Unavailable → "Storage service temporarily unavailable"

### Security Considerations

1. **File Validation:**
   - Check magic numbers, not just extension
   - Validate MIME type from file content
   - Strip EXIF data to remove metadata
   - Validate image dimensions (min 100px, max 4000px)

2. **Virus Scanning:**
   - Use ClamAV for server-side scanning
   - Or integrate AWS GuardDuty for S3
   - Quarantine suspicious files

3. **S3 Security:**
   - Use signed URLs for uploads
   - Set proper CORS policy
   - Enable versioning for accidental deletes
   - Set bucket policy for public read, private write

## Dependencies

- **ENG-001** - Database schema must include profile_picture_url column

## Testing Requirements

### Unit Tests

```javascript
describe('ImageProcessingService', () => {
  it('generates all 4 sizes correctly');
  it('converts to WebP format');
  it('crops to square aspect ratio');
  it('maintains quality at 90%');
  it('throws error for corrupt images');
});

describe('ImageValidationService', () => {
  it('rejects files over 5MB');
  it('rejects invalid formats');
  it('validates magic numbers');
  it('strips EXIF data');
});
```

### Integration Tests

```javascript
describe('POST /api/v1/profile/picture', () => {
  it('uploads valid image successfully');
  it('returns CloudFront URLs for all sizes');
  it('updates database with new URL');
  it('deletes old profile picture from S3');
  it('rejects file over 5MB');
  it('rejects invalid format');
  it('respects rate limit');
  it('handles S3 upload failure gracefully');
});

describe('DELETE /api/v1/profile/picture', () => {
  it('deletes all 4 sizes from S3');
  it('clears database URL');
  it('returns 204 status');
  it('handles case where file already deleted');
});
```

### Manual Tests

1. Upload 2MB JPEG → Verify all 4 sizes created in S3
2. Upload 6MB image → Verify rejection with clear error
3. Upload PNG → Verify conversion to WebP
4. Upload corrupted file → Verify error handling
5. Upload then delete → Verify S3 cleanup
6. Upload 6 images in hour → Verify rate limiting
7. Simulate S3 failure → Verify error handling
8. Check CloudFront URLs work → Load images in browser

## Implementation Checklist

- [ ] Install dependencies (multer, sharp, aws-sdk, browser-image-compression)
- [ ] Configure AWS credentials and S3 bucket
- [ ] Create ImageProcessingService class
- [ ] Create S3Service class with upload/delete methods
- [ ] Create validation middleware
- [ ] Implement malware scanning (ClamAV or GuardDuty)
- [ ] Implement upload endpoint
- [ ] Implement delete endpoint
- [ ] Add rate limiting
- [ ] Handle old image cleanup
- [ ] Create unit tests for image processing
- [ ] Create integration tests for API endpoints
- [ ] Test with various image formats and sizes
- [ ] Configure CloudFront distribution
- [ ] Add upload progress tracking (optional)
- [ ] Code review
- [ ] Load test with concurrent uploads
- [ ] Deploy to staging
- [ ] QA testing
- [ ] Deploy to production

## Files to Create/Modify

**New Files:**
- `src/services/ImageProcessingService.ts`
- `src/services/S3Service.ts`
- `src/middleware/uploadMiddleware.ts`
- `src/middleware/validateImage.ts`
- `src/controllers/ProfilePictureController.ts`
- `src/utils/virusScanner.ts`
- `tests/unit/imageProcessing.test.ts`
- `tests/integration/profilePicture.test.ts`
- `client/src/utils/imageCompression.ts`

**Modified Files:**
- `src/routes/api.ts` (add routes)
- `package.json` (add dependencies)
- `.env.example` (add AWS config)

## Reference Documents

- Technical Specification: Section 3 (Implementation Notes - Image Processing Pipeline)
- Engineer Output: Image Processing section
- Technology Choices: aws-sdk, sharp, multer

## Notes

- Sharp is CPU-intensive; consider offloading to worker threads or separate service for high traffic
- S3 uploads are synchronous; consider async job queue for better performance
- CloudFront cache takes time to propagate; use cache invalidation for immediate updates
- WebP not supported in older browsers; consider serving JPEG fallback
- Monitor S3 costs; implement lifecycle policy to delete old images
- Consider implementing image optimization (tinypng API) for further size reduction

## Risks & Mitigation

**Risk**: Sharp processing blocks event loop under heavy load  
**Mitigation**: Use worker threads or separate microservice, implement queue

**Risk**: S3 upload failures leave orphaned files  
**Mitigation**: Implement cleanup job, use transaction-like pattern

**Risk**: Malware uploaded despite scanning  
**Mitigation**: Use multiple scanning services, implement user reporting

**Risk**: Storage costs escalate with many uploads  
**Mitigation**: Implement S3 lifecycle policy, monitor costs, compress aggressively

**Risk**: Image processing takes too long (> 5s)  
**Mitigation**: Optimize Sharp settings, implement async processing with webhooks

