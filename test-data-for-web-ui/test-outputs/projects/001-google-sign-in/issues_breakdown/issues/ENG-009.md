# Create protected route component

**Issue ID**: ENG-009  
**Status**: pending  
**Priority**: medium  
**Category**: frontend  
**Complexity Score**: 4/10  
**Estimated Hours**: 3h  
**Complexity Reasoning**: Standard route protection pattern in React

> **Status Options**: `pending` (not started) | `in-review` (AI completed, needs human review) | `approved` (human verified)

## Description

Build ProtectedRoute wrapper component that checks if user is authenticated before rendering protected pages. Redirect unauthenticated users to login page.

## Technical Details

```typescript
interface ProtectedRouteProps {
  children: React.ReactNode;
  requireAuth?: boolean;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requireAuth = true 
}) => {
  const { isAuthenticated, loading } = useAuth();
  const location = useLocation();
  
  if (loading) {
    return <LoadingSpinner />;
  }
  
  if (requireAuth && !isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }
  
  return <>{children}</>;
};
```

Usage:
```typescript
<Route path="/dashboard" element={
  <ProtectedRoute>
    <Dashboard />
  </ProtectedRoute>
} />
```

## Dependencies

- **ENG-006**: Requires AuthContext for authentication state

## Acceptance Criteria

- [ ] Component checks authentication status
- [ ] Unauthenticated users redirected to login
- [ ] Original destination saved for post-login redirect
- [ ] Loading state shown during auth check
- [ ] Works with React Router
- [ ] No flicker during auth check
- [ ] Handles edge cases (expired tokens, etc.)

## Test Strategy

### Automated Tests

- Authenticated user can access protected route
- Unauthenticated user redirected to login
- Loading state shown while checking auth
- Original destination preserved in state
- Component re-renders on auth state change

### Manual Verification (Human-in-the-Loop)

1. Try accessing protected route while logged out
2. Verify redirect to login page
3. Log in and verify redirect back to intended page
4. Log out and verify kicked out of protected pages
5. Refresh page on protected route (should stay if logged in)

## Subtasks

1. Create ProtectedRoute component
2. Integrate with AuthContext
3. Implement redirect logic
4. Add loading state
5. Save intended destination
6. Wrap protected routes
7. Test all scenarios

---

**Notes**: Consider role-based access control (RBAC) for future enhancement. Ensure smooth UX with proper loading states.




