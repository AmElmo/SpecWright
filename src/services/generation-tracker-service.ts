/**
 * Generation Tracker Service
 *
 * Tracks which phases are currently being generated by the AI.
 * This allows the frontend to restore the "working" state after page reload.
 *
 * The tracker uses in-memory state with a timeout mechanism to auto-expire
 * stale entries (e.g., if the server restarts or generation hangs).
 */

import { logger } from '../utils/logger.js';

interface GenerationEntry {
  startedAt: Date;
  phase: string;
  projectId?: string;
}

// In-memory store for active generations
// Keys are: 'scoping', 'breakdown:{projectId}', or 'spec:{projectId}'
const activeGenerations = new Map<string, GenerationEntry>();

// Maximum time a generation can be "active" before auto-expiring (30 minutes)
const GENERATION_TIMEOUT_MS = 30 * 60 * 1000;

/**
 * Check if a generation entry is still valid (not expired)
 */
function isEntryValid(entry: GenerationEntry): boolean {
  const elapsed = Date.now() - entry.startedAt.getTime();
  return elapsed < GENERATION_TIMEOUT_MS;
}

/**
 * Clean up expired entries
 */
function cleanupExpiredEntries(): void {
  const keysToDelete: string[] = [];

  activeGenerations.forEach((entry, key) => {
    if (!isEntryValid(entry)) {
      keysToDelete.push(key);
      logger.debug(`ðŸ§¹ [Generation Tracker] Auto-expiring stale generation: ${key} (started ${entry.startedAt.toISOString()})`);
    }
  });

  keysToDelete.forEach(key => activeGenerations.delete(key));
}

// Scoping tracking
export function markScopingGenerating(): void {
  cleanupExpiredEntries();
  activeGenerations.set('scoping', {
    startedAt: new Date(),
    phase: 'scoping'
  });
  logger.debug('ðŸš€ [Generation Tracker] Scoping generation started');
}

export function markScopingComplete(): void {
  activeGenerations.delete('scoping');
  logger.debug('âœ… [Generation Tracker] Scoping generation complete');
}

export function isScopingGenerating(): { isGenerating: boolean; startedAt?: string } {
  cleanupExpiredEntries();
  const entry = activeGenerations.get('scoping');

  if (entry && isEntryValid(entry)) {
    return { isGenerating: true, startedAt: entry.startedAt.toISOString() };
  }

  return { isGenerating: false };
}

// Specification phase tracking
export function markSpecPhaseGenerating(projectId: string, phase: string): void {
  cleanupExpiredEntries();
  const key = `spec:${projectId}`;
  activeGenerations.set(key, {
    startedAt: new Date(),
    phase,
    projectId
  });
  logger.debug(`ðŸš€ [Generation Tracker] Spec phase generation started: ${projectId}/${phase}`);
}

export function markSpecPhaseComplete(projectId: string): void {
  const key = `spec:${projectId}`;
  activeGenerations.delete(key);
  logger.debug(`âœ… [Generation Tracker] Spec phase generation complete: ${projectId}`);
}

export function getSpecGeneratingPhase(projectId: string): { isGenerating: boolean; phase?: string; startedAt?: string } {
  cleanupExpiredEntries();
  const key = `spec:${projectId}`;
  const entry = activeGenerations.get(key);

  if (entry && isEntryValid(entry)) {
    return {
      isGenerating: true,
      phase: entry.phase,
      startedAt: entry.startedAt.toISOString()
    };
  }

  return { isGenerating: false };
}

// Breakdown tracking
export function markBreakdownGenerating(projectId: string): void {
  cleanupExpiredEntries();
  const key = `breakdown:${projectId}`;
  activeGenerations.set(key, {
    startedAt: new Date(),
    phase: 'issue-breakdown',
    projectId
  });
  logger.debug(`ðŸš€ [Generation Tracker] Breakdown generation started: ${projectId}`);
}

export function markBreakdownComplete(projectId: string): void {
  const key = `breakdown:${projectId}`;
  activeGenerations.delete(key);
  logger.debug(`âœ… [Generation Tracker] Breakdown generation complete: ${projectId}`);
}

export function isBreakdownGenerating(projectId: string): { isGenerating: boolean; startedAt?: string } {
  cleanupExpiredEntries();
  const key = `breakdown:${projectId}`;
  const entry = activeGenerations.get(key);

  if (entry && isEntryValid(entry)) {
    return { isGenerating: true, startedAt: entry.startedAt.toISOString() };
  }

  return { isGenerating: false };
}

// Debug function to see all active generations
export function getActiveGenerations(): Map<string, GenerationEntry> {
  cleanupExpiredEntries();
  return new Map(activeGenerations);
}
