/**
 * Canvas - Auto-generated by Explorer
 * 
 * This file enables isolated component/page preview with mock data.
 * DO NOT EDIT - This file is managed by the Explorer tool.
 * 
 * Generated glob patterns based on your project structure:
 * /src/components, /src/components/ui
 */
'use client';

import React, { useState, useEffect, Suspense, Component, type ReactNode, type ErrorInfo } from 'react';
import { useSearchParams } from 'react-router-dom';
import * as ReactRouterDOM from 'react-router-dom';
import { logger } from './utils/logger';

// ==================== RESILIENT ROUTER DETECTION ====================
// Detect React Router version and available contexts
// This enables route params injection without creating nested routers

type RouterCapabilities = {
  version: 'v6' | 'v5' | 'unknown';
  hasUnsafeContexts: boolean;
  RouteContext: React.Context<any> | null;
  LocationContext: React.Context<any> | null;
  DataRouterContext: React.Context<any> | null;
};

function detectRouterCapabilities(): RouterCapabilities {
  const rr = ReactRouterDOM as any;
  
  // Check for React Router v6 UNSAFE_* contexts
  const hasV6Contexts = !!(rr.UNSAFE_RouteContext && rr.UNSAFE_LocationContext);
  
  if (hasV6Contexts) {
    logger.debug('[Canvas] React Router v6 detected with UNSAFE contexts');
    return {
      version: 'v6',
      hasUnsafeContexts: true,
      RouteContext: rr.UNSAFE_RouteContext,
      LocationContext: rr.UNSAFE_LocationContext,
      DataRouterContext: rr.UNSAFE_DataRouterContext || null
    };
  }
  
  // Check for React Router v5 __RouterContext
  if (rr.__RouterContext) {
    logger.debug('[Canvas] React Router v5 detected');
    return {
      version: 'v5',
      hasUnsafeContexts: false,
      RouteContext: rr.__RouterContext,
      LocationContext: null,
      DataRouterContext: null
    };
  }
  
  logger.warn('[Canvas] Could not detect React Router version - route params injection may not work');
  return {
    version: 'unknown',
    hasUnsafeContexts: false,
    RouteContext: null,
    LocationContext: null,
    DataRouterContext: null
  };
}

const routerCapabilities = detectRouterCapabilities();

// ==================== ERROR BOUNDARY ====================
// Catches errors in route params injection and falls back to rendering without params
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class RouteParamsErrorBoundary extends Component<
  { children: ReactNode; fallback: ReactNode },
  ErrorBoundaryState
> {
  constructor(props: { children: ReactNode; fallback: ReactNode }) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, _errorInfo: ErrorInfo) {
    logger.warn('[Canvas] Route params injection failed, rendering without params:', error.message);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}

// Explorer server URL
const EXPLORER_SERVER = 'http://localhost:3050';

// ==================== DYNAMIC COMPONENT LOADING ====================
// Using import.meta.glob with patterns detected from your project structure
const modules = import.meta.glob([
    '/src/components/**/*.tsx',
    '/src/components/**/*.ts',
    '/src/components/ui/**/*.tsx',
    '/src/components/ui/**/*.ts',
    '/components/**/*.tsx',
    '/components/**/*.ts'
]);

logger.debug('[Canvas] Available modules:', Object.keys(modules).length);

// ==================== FETCH MOCKING ====================
interface MockApiConfig {
  [endpoint: string]: any;
}

let originalFetch: typeof fetch;
let mockApiConfig: MockApiConfig = {};

// Convert route pattern to regex for flexible matching (fallback if route params injection fails)
// e.g., "/api/projects/:id" matches "/api/projects/123" and "/api/projects/undefined"
function createPatternMatcher(pattern: string): RegExp {
  const escaped = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regexPattern = escaped.replace(/:([a-zA-Z_][a-zA-Z0-9_]*)/g, '([^/]+)');
  return new RegExp(regexPattern);
}

function createMockResponse(mockData: any): Response {
  if (mockData?.__delay) {
    return new Promise(() => {}) as any;
  }
  
  if (mockData?.__error) {
    return new Response(JSON.stringify(mockData.__error), {
      status: mockData.__error.status || 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  return new Response(JSON.stringify(mockData), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  });
}

function setupFetchMocking(mockApi: MockApiConfig) {
  mockApiConfig = mockApi;
  
  if (!originalFetch) {
    originalFetch = window.fetch;
  }
  
  window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {
    const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
    const method = init?.method?.toUpperCase() || 'GET';
    
    // Check if this endpoint should be mocked
    for (const [endpoint, mockData] of Object.entries(mockApiConfig)) {
      // Parse endpoint pattern (e.g., "GET /api/users" or just "/api/users")
      const [mockMethod, mockPath] = endpoint.includes(' ') 
        ? endpoint.split(' ') 
        : ['GET', endpoint];
      
      // Try exact match first
      if (url.includes(mockPath) && method === mockMethod.toUpperCase()) {
        logger.debug('[Canvas] Mocking API (exact):', method, url, '→', mockData);
        return createMockResponse(mockData);
      }
      
      // Try pattern matching (for routes with :params) as fallback
      if (mockPath.includes(':')) {
        const pattern = createPatternMatcher(mockPath);
        if (pattern.test(url) && method === mockMethod.toUpperCase()) {
          logger.debug('[Canvas] Mocking API (pattern):', method, url, 'matched', mockPath, '→', mockData);
          return createMockResponse(mockData);
        }
      }
    }
    
    return originalFetch(input, init);
  };
}


function cleanupFetchMocking() {
  if (originalFetch) {
    window.fetch = originalFetch;
  }
  mockApiConfig = {};
}

// ==================== STORY FETCHING ====================
interface Story {
  id: string;
  name: string;
  description?: string;
  props?: Record<string, any>;
  routeParams?: Record<string, string>;
  mockApi?: MockApiConfig;
  mockContext?: Record<string, any>;
}

interface StoriesFile {
  componentName?: string;
  pageName?: string;
  pageRoute?: string;
  type: 'component' | 'page';
  stories: Story[];
}

interface StoryData {
  story: Story | null;
  pageRoute: string | null;
  error: string | null;
}

async function fetchStoryData(
  type: 'component' | 'page',
  name: string,
  storyId: string
): Promise<StoryData> {
  try {
    const response = await fetch(
      `${EXPLORER_SERVER}/api/stories/${type}/${encodeURIComponent(name)}`
    );
    
    if (!response.ok) {
      return { story: null, pageRoute: null, error: 'No stories found' };
    }
    
    const storiesFile: StoriesFile = await response.json();
    const story = storiesFile.stories.find(s => s.id === storyId) || storiesFile.stories[0];
    
    return { story, pageRoute: storiesFile.pageRoute || null, error: null };
  } catch (error) {
    logger.error('[Canvas] Failed to fetch story:', error);
    return { story: null, pageRoute: null, error: 'Failed to connect to Explorer server' };
  }
}

// ==================== ROUTE PARAMS HELPER ====================
// Build the actual URL from a route pattern and params
// e.g., "/specification/:projectId" + { projectId: "my-app" } => "/specification/my-app"
function buildRouteUrl(routePattern: string, params: Record<string, string>): string {
  let url = routePattern;
  for (const [key, value] of Object.entries(params)) {
    url = url.replace(`:${key}`, value);
  }
  return url;
}

// ==================== ROUTE PARAMS PROVIDER ====================
// Provides route params via React Router's internal contexts WITHOUT creating a new router
// This avoids the "nested router" error while still making useParams() work
// Supports React Router v5, v6, and gracefully degrades for unknown versions
interface RouteParamsProviderProps {
  pageRoute: string;
  routeParams: Record<string, string>;
  children: React.ReactNode;
}

function RouteParamsProviderV6({ pageRoute, routeParams, children }: RouteParamsProviderProps) {
  const pathname = buildRouteUrl(pageRoute, routeParams);
  
  const { RouteContext, LocationContext, DataRouterContext } = routerCapabilities;
  
  if (!RouteContext || !LocationContext) {
    logger.warn('[Canvas] V6 contexts not available, rendering without params');
    return <>{children}</>;
  }
  
  // Create a mock location object
  const location = {
    pathname,
    search: '',
    hash: '',
    state: null,
    key: 'preview'
  };
  
  // Create mock route context that provides the params
  const routeContext = {
    outlet: null,
    matches: [{
      params: routeParams,
      pathname,
      pathnameBase: pathname,
      route: { path: pageRoute }
    }],
    isDataRoute: false
  };
  
  // Create mock location context  
  const locationContext = {
    location,
    navigationType: 'POP'
  };
  
  // Build the provider tree - DataRouterContext may or may not exist
  let element = (
    <LocationContext.Provider value={locationContext}>
      <RouteContext.Provider value={routeContext}>
        {children}
      </RouteContext.Provider>
    </LocationContext.Provider>
  );
  
  if (DataRouterContext) {
    element = <DataRouterContext.Provider value={null}>{element}</DataRouterContext.Provider>;
  }
  
  return element;
}

function RouteParamsProviderV5({ pageRoute, routeParams, children }: RouteParamsProviderProps) {
  const pathname = buildRouteUrl(pageRoute, routeParams);
  const { RouteContext } = routerCapabilities;
  
  if (!RouteContext) {
    logger.warn('[Canvas] V5 RouterContext not available, rendering without params');
    return <>{children}</>;
  }
  
  // React Router v5 uses a single context with match, location, history
  const contextValue = {
    match: {
      params: routeParams,
      isExact: true,
      path: pageRoute,
      url: pathname
    },
    location: {
      pathname,
      search: '',
      hash: '',
      state: null,
      key: 'preview'
    },
    history: {
      length: 1,
      action: 'POP',
      location: { pathname, search: '', hash: '', state: null, key: 'preview' },
      push: () => logger.warn('[Canvas] Navigation disabled in preview'),
      replace: () => logger.warn('[Canvas] Navigation disabled in preview'),
      go: () => {},
      goBack: () => {},
      goForward: () => {},
      block: () => () => {},
      listen: () => () => {},
      createHref: (loc: any) => typeof loc === 'string' ? loc : loc.pathname || ''
    }
  };
  
  return <RouteContext.Provider value={contextValue}>{children}</RouteContext.Provider>;
}

function RouteParamsProvider({ pageRoute, routeParams, children }: RouteParamsProviderProps) {
  const pathname = buildRouteUrl(pageRoute, routeParams);
  logger.debug('[Canvas] RouteParamsProvider:', { 
    pageRoute, 
    routeParams, 
    pathname,
    routerVersion: routerCapabilities.version 
  });
  
  // Use version-specific provider
  if (routerCapabilities.version === 'v6') {
    return (
      <RouteParamsProviderV6 pageRoute={pageRoute} routeParams={routeParams}>
        {children}
      </RouteParamsProviderV6>
    );
  }
  
  if (routerCapabilities.version === 'v5') {
    return (
      <RouteParamsProviderV5 pageRoute={pageRoute} routeParams={routeParams}>
        {children}
      </RouteParamsProviderV5>
    );
  }
  
  // Unknown version - just render children without params injection
  logger.warn('[Canvas] Unknown router version, rendering without route params injection');
  return <>{children}</>;
}

// ==================== DYNAMIC COMPONENT LOADER ====================
interface DynamicComponentProps {
  componentName: string;
  props: Record<string, any>;
  routeParams?: Record<string, string>;
  pageRoute?: string | null;
}

// Helper to convert string to PascalCase
function toPascalCase(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Helper to normalize names (removes hyphens/underscores, lowercases)
// This handles kebab-case filenames matching PascalCase imports
// e.g., "user-name-form" -> "usernameform" and "UserNameForm" -> "usernameform"
function normalizeForMatch(str: string): string {
  return str.replace(/[-_]/g, '').toLowerCase();
}

// Find a module that matches the component name
async function findAndLoadModule(componentName: string): Promise<any> {
  const lowerName = componentName.toLowerCase();
  const pascalName = toPascalCase(componentName);
  const normalizedName = normalizeForMatch(componentName);
  
  // Search through all available modules
  for (const [modulePath, loader] of Object.entries(modules)) {
    // Extract filename from path (e.g., '/src/components/ui/button.tsx' -> 'button')
    const fileName = modulePath.split('/').pop()?.replace(/\.(tsx?|jsx?)$/, '') || '';
    const fileNameLower = fileName.toLowerCase();
    const fileNameNormalized = normalizeForMatch(fileName);
    
    // Match by filename - try multiple strategies:
    // 1. Exact match
    // 2. Case-insensitive match
    // 3. Normalized match (handles kebab-case <-> PascalCase)
    if (fileName === componentName || 
        fileName === pascalName || 
        fileNameLower === lowerName || 
        fileNameNormalized === normalizedName) {
      logger.debug('[Canvas] Found module for', componentName, ':', modulePath);
      return await (loader as () => Promise<any>)();
    }
  }
  
  // If no exact filename match, try path contains (normalized)
  for (const [modulePath, loader] of Object.entries(modules)) {
    const pathNormalized = normalizeForMatch(modulePath);
    if (pathNormalized.includes('/' + normalizedName + '.') ||
        pathNormalized.includes('/' + normalizedName + '/')) {
      logger.debug('[Canvas] Found module (path match) for', componentName, ':', modulePath);
      return await (loader as () => Promise<any>)();
    }
  }
  
  logger.error('[Canvas] No module found for:', componentName);
  logger.error('[Canvas] Available modules:', Object.keys(modules).slice(0, 15), '...');
  return null;
}

function DynamicComponent({ componentName, props, routeParams, pageRoute }: DynamicComponentProps) {
  const [Component, setComponent] = useState<React.ComponentType<any> | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadComponent = async () => {
      try {
        const module = await findAndLoadModule(componentName);
        
        if (!module) {
          setError(`Component "${componentName}" not found. Available modules: ${Object.keys(modules).length}`);
          return;
        }
        
        // Try multiple variations to find the component export
        const pascalName = toPascalCase(componentName);
        const Comp = module[componentName] || module[pascalName] || module.default;
        
        if (!Comp) {
          logger.error('[Canvas] Available exports:', Object.keys(module));
          setError(`Component "${componentName}" not exported. Available: ${Object.keys(module).join(', ')}`);
          return;
        }
        
        logger.debug('[Canvas] Loaded component:', componentName);
        setComponent(() => Comp);
      } catch (err) {
        logger.error('[Canvas] Failed to load component:', err);
        setError(`Failed to load component: ${err}`);
      }
    };
    
    loadComponent();
  }, [componentName]);

  if (error) {
    return (
      <div style={{ padding: 20, color: 'red', fontFamily: 'monospace' }}>
        <strong>Error:</strong> {error}
      </div>
    );
  }

  if (!Component) {
    return (
      <div style={{ padding: 20, color: '#666' }}>
        Loading component...
      </div>
    );
  }

  // If we have routeParams and a pageRoute, provide them via React Router's internal contexts
  // This makes useParams() return the mock params without creating a nested router
  // Wrapped in error boundary for resilience - if injection fails, falls back to rendering without params
  const hasRouteParams = routeParams && pageRoute && Object.keys(routeParams).length > 0;
  
  if (hasRouteParams && pageRoute) {
    const componentWithoutParams = <Component {...props} />;
    
    return (
      <RouteParamsErrorBoundary fallback={componentWithoutParams}>
        <RouteParamsProvider pageRoute={pageRoute} routeParams={routeParams!}>
          <Component {...props} />
        </RouteParamsProvider>
      </RouteParamsErrorBoundary>
    );
  }

  return <Component {...props} />;
}

// ==================== MAIN PREVIEW COMPONENT ====================
export default function Canvas() {
  const [searchParams] = useSearchParams();
  const componentName = searchParams.get('component') || '';
  const pageName = searchParams.get('page') || '';
  const storyId = searchParams.get('story') || 'default';
  
  // Determine if we're previewing a component or page
  const isPage = !!pageName;
  const itemName = pageName || componentName;
  const itemType = isPage ? 'page' : 'component';
  
  const [story, setStory] = useState<Story | null>(null);
  const [pageRoute, setPageRoute] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadStory = async () => {
      setLoading(true);
      setError(null);
      
      if (!itemName) {
        setError('No component or page specified. Use ?component=Name or ?page=Name');
        setLoading(false);
        return;
      }
      
      logger.debug('[Canvas] Loading', { itemType, itemName, storyId });
      
      // Fetch story data from Explorer
      const storyData = await fetchStoryData(
        itemType,
        itemName,
        storyId
      );
      
      if (storyData.error) {
        setError(storyData.error);
        setLoading(false);
        return;
      }
      
      if (storyData.story) {
        setStory(storyData.story);
        setPageRoute(storyData.pageRoute);
        
        // Log route params info for debugging
        if (storyData.story.routeParams && Object.keys(storyData.story.routeParams).length > 0) {
          logger.debug('[Canvas] Story has routeParams:', storyData.story.routeParams);
          logger.debug('[Canvas] Page route:', storyData.pageRoute);
        }
        
        // Setup fetch mocking if story has mockApi
        if (storyData.story.mockApi && Object.keys(storyData.story.mockApi).length > 0) {
          logger.debug('[Canvas] Setting up fetch mocking for:', Object.keys(storyData.story.mockApi));
          setupFetchMocking(storyData.story.mockApi);
        }
      }
      
      setLoading(false);
    };
    
    loadStory();
    
    // Cleanup on unmount
    return () => {
      cleanupFetchMocking();
    };
  }, [itemName, itemType, storyId]);

  // Loading state
  if (loading) {
    return (
      <div style={{ 
        display: 'flex', 
        alignItems: 'center', 
        justifyContent: 'center', 
        height: '100vh',
        fontFamily: 'system-ui, sans-serif',
        color: '#666'
      }}>
        <div style={{ textAlign: 'center' }}>
          <div style={{ marginBottom: 8 }}>Loading preview...</div>
          <div style={{ fontSize: 12, opacity: 0.7 }}>
            {itemType}: {itemName} / {storyId}
          </div>
        </div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div style={{ 
        padding: 20, 
        fontFamily: 'system-ui, sans-serif'
      }}>
        <div style={{ 
          padding: 16, 
          background: '#fef2f2', 
          border: '1px solid #fecaca',
          borderRadius: 8,
          color: '#991b1b'
        }}>
          <strong>Preview Error</strong>
          <div style={{ marginTop: 8, fontSize: 14 }}>{error}</div>
          <div style={{ marginTop: 12, fontSize: 12, opacity: 0.7 }}>
            {itemType}: {itemName}<br />
            Story: {storyId}
          </div>
        </div>
      </div>
    );
  }

  // No story found
  if (!story) {
    return (
      <div style={{ 
        padding: 20, 
        fontFamily: 'system-ui, sans-serif'
      }}>
        <div style={{ 
          padding: 16, 
          background: '#fefce8', 
          border: '1px solid #fef08a',
          borderRadius: 8,
          color: '#854d0e'
        }}>
          <strong>No Story Found</strong>
          <div style={{ marginTop: 8, fontSize: 14 }}>
            Generate stories for this {itemType} using the Explorer.
          </div>
        </div>
      </div>
    );
  }

  // Render component/page with story props
  const props = story.props || {};

  return (
    <div style={{ padding: 20 }}>
      {/* Story Info Header */}
      <div style={{ 
        marginBottom: 16, 
        paddingBottom: 16, 
        borderBottom: '1px solid #e5e7eb',
        fontFamily: 'system-ui, sans-serif'
      }}>
        <div style={{ 
          fontSize: 12, 
          color: '#6b7280',
          marginBottom: 4 
        }}>
          <span style={{ 
            padding: '2px 6px', 
            background: isPage ? '#dbeafe' : '#f3e8ff',
            color: isPage ? '#1d4ed8' : '#7c3aed',
            borderRadius: 4,
            fontSize: 10,
            marginRight: 8,
            textTransform: 'uppercase'
          }}>
            {itemType}
          </span>
          {itemName}
        </div>
        <div style={{ 
          fontSize: 16, 
          fontWeight: 600,
          color: '#111827'
        }}>
          {story.name}
        </div>
        {story.description && (
          <div style={{ 
            fontSize: 13, 
            color: '#6b7280',
            marginTop: 4 
          }}>
            {story.description}
          </div>
        )}
      </div>

      {/* Component/Page Render */}
      <Suspense fallback={<div>Loading...</div>}>
        <DynamicComponent 
          componentName={itemName} 
          props={props} 
          routeParams={story.routeParams}
          pageRoute={pageRoute}
        />
      </Suspense>
      
      {/* Props Debug (only show if there are props) */}
      {Object.keys(props).length > 0 && (
        <div style={{ 
          marginTop: 24,
          padding: 12,
          background: '#f9fafb',
          borderRadius: 6,
          fontFamily: 'monospace',
          fontSize: 11
        }}>
          <div style={{ 
            fontSize: 10, 
            color: '#6b7280',
            marginBottom: 8,
            textTransform: 'uppercase',
            letterSpacing: '0.05em'
          }}>
            Props
          </div>
          <pre style={{ margin: 0, whiteSpace: 'pre-wrap' }}>
            {JSON.stringify(props, null, 2)}
          </pre>
        </div>
      )}
      
      {/* Route Params Debug */}
      {story.routeParams && Object.keys(story.routeParams).length > 0 && pageRoute && (
        <div style={{ 
          marginTop: 12,
          padding: 12,
          background: '#f0fdf4',
          borderRadius: 6,
          fontFamily: 'monospace',
          fontSize: 11,
          border: '1px solid #bbf7d0'
        }}>
          <div style={{ 
            fontSize: 10, 
            color: '#166534',
            marginBottom: 8,
            textTransform: 'uppercase',
            letterSpacing: '0.05em'
          }}>
            Route Params (via MemoryRouter)
          </div>
          <div style={{ marginBottom: 4, color: '#166534' }}>
            Route: {pageRoute} → {buildRouteUrl(pageRoute, story.routeParams)}
          </div>
          <div style={{ display: 'flex', flexWrap: 'wrap', gap: 4 }}>
            {Object.entries(story.routeParams).map(([key, value], i) => (
              <span key={i} style={{
                padding: '2px 8px',
                background: '#bbf7d0',
                color: '#166534',
                borderRadius: 4,
                fontSize: 11
              }}>
                :{key} = "{value}"
              </span>
            ))}
          </div>
        </div>
      )}
      
      {/* Mocked APIs Debug */}
      {story.mockApi && Object.keys(story.mockApi).length > 0 && (
        <div style={{ 
          marginTop: 12,
          padding: 12,
          background: '#fffbeb',
          borderRadius: 6,
          fontFamily: 'monospace',
          fontSize: 11,
          border: '1px solid #fef3c7'
        }}>
          <div style={{ 
            fontSize: 10, 
            color: '#92400e',
            marginBottom: 8,
            textTransform: 'uppercase',
            letterSpacing: '0.05em'
          }}>
            Mocked APIs
          </div>
          <div style={{ display: 'flex', flexWrap: 'wrap', gap: 4 }}>
            {Object.keys(story.mockApi).map((endpoint, i) => (
              <span key={i} style={{
                padding: '2px 8px',
                background: '#fef3c7',
                color: '#92400e',
                borderRadius: 4,
                fontSize: 11
              }}>
                {endpoint}
              </span>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
